%> @file AbstractGrid.m All grid classes should inherit this class.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%> All grid classes should inherit this class.
classdef AbstractGrid < hgsetget & handle

    properties (SetAccess = public) % only own and derived instances

        %% constants
        %> <b>Number of triangles</b> @f$\#T@f$.
        numT
        %> <b>Number of edges</b> @f$\#E@f$.
        numE
        %> <b>Number of vertices</b> @f$\#V@f$.
        numV

        % basic geometry and topology (required as input in constructor)
        %> <b>&ldquo;Coordinates of vertices&rdquo;</b> @f$[\#V \times 2]@f$.
        %> @f[\mathtt{coordV} = \begin{bmatrix}x_{V_1}&y_{V_1}\\x_{V_2}&y_{V_2}\\\vdots&\vdots\\x_{V_\mathrm{end}}&y_{V_\mathrm{end}} \end{bmatrix}@f]
        %> @note If you want to implement <i>periodic</i> boundary conditions
        %> (FoldedGrid) then you must use AbstractGrid.coordV0T instead!
        coordV % [#V x 2]
        %> <b>&ldquo;Vertices of triangles&rdquo;</b> @f$[\#T \times 3]@f$.
        V0T % [#T x 3]

        %% topology (evaluated when constructor is called)
        %> <b>&ldquo;Vertices to triangle&rdquo;</b> @f$[\#V \times \#V]@f$.
        %> If the vertices @c jV, @c kV are vertices of the same triangle <i>in counter-clockwise order</i>, then <code>V2T(jV, kV)</code>
        %> returns the triangle's number.
        V2T % [#V x #V]
        %> <b>&ldquo;Vertices to edge&rdquo;</b> @f$[\#V \times \#V]@f$.
        V2E % [#V x #V]
        %> <b>&ldquo;Vertices of edges&rdquo;</b> @f$[\#E \times 2]@f$.
        V0E % [#E x 2 ]
        %> <b>&ldquo;Triangles of edges&rdquo;</b> @f$[\#E \times 2]@f$.
        T0E % [#E x 2 ]
        %> <b>&ldquo;Edges of triangles&rdquo;</b> @f$[\#T \times 3]@f$.
        E0T % [#T x 3 ]

        %% geometry (evaluated when constructor is called)
        %> <b>Length of edges</b> @f$|E|@f$ @f$[\#E \times 1]@f$.
        areaE % [#E x 1 ]    % egde lengths
        %> <b>Barycenters of edges</b> @f$\vec{x}_E^\mathrm{bary}@f$ @f$[\#E \times 2]@f$.
        %> @note If you want to implement <i>periodic</i> boundary conditions
        %> (FoldedGrid) then you must use AbstractGrid.baryE0T instead!
        baryE % [#E x 2 ]    % barycenter of edges
        %> <b>Edge vectors</b> @f$[\#E \times 2 ]@f$
        vecE % [#E x 2 ]    % edge as vector (`tip minus foot')
        %> <b>Unit normals of edges</b> under global orientation @f$\vec{\nu}_E@f$ @f$[\#E \times 2]@f$. The local (triangle-related) normals are @f$\vec{\nu}_{ET}=\sigma_{ET}\vec{\nu}_{E}@f$.
        nuE % [#E x 2 ]    % unit normals on edges
        %> <b>Area of triangles</b> @f$[\#T \times 1 ]@f$
        areaT % [#T x 1 ]    % area of triangle
        %> <b>Barycenters of triangles</b> @f$[\#T \times 2 ]@f$
        baryT % [#T x 2 ]    % barycenter of triangles

        %% geometry with local indexing (evaluated when constructor is called)
        %> <b>Coordinates of vertices</b> with <i>local</i> vertex numbering @f$[\#T \times 3 \times 2]@f$
        coordV0T % [#T x 3 x 2] % coordinates of vertices of triangles with local vertex numbering.
        %> <b>Barycenters of edges</b> with <i>local</i> edge numbering @f$\vec{x}_{E\subset T}^\mathrm{bary}@f$ @f$[\#T \times 3 \times 2]@f$ to be used with FoldedGrid.
        baryE0T % [#T x 3 x 2] % barycenters of edges of a triangle with local edge numbering.
        % Last index is the component. Use squeeze(m, n, :) to obtain a vector

        % topology with local indexing (evaluated when constructor is called)
        %> <b>Signs of edges</b> @f$[\#T\times 3]@f$
        %> This matrix describes the local orientation of each element's three
        %> edges.  An edge is positive with respect to an element, if it points
        %> in counter-clockwise direction.
        sigE0T % [#T x 3]

        %> Jacobian @f$\mathbf{A}@f$ of affine mappings @f$\hat{T} \rightarrow T@f$, @f$\vec{x} \mapsto \mathbf{A}\vec{x} + \vec{b}@f$.
        A % [#T x 2 x 2] % get the Jacobian of kT by squeeze(A(kT,:,:))

        %> Right-hand side @f$\vec{b}@f$ affine mappings @f$\hat{T} \rightarrow T@f$, @f$\vec{x} \mapsto \mathbf{A}\vec{x} + \vec{b}@f$.
        b % [#T x 2]
    end % private properties

    properties (Access = public) %> @todo dangerous
        %> <b>Edge IDs</b> @f$[\#E\times 1]@f$. Each <i>boundary</i> edge usually is associated with a type of boundary condition.
        %> In order to identify the specific edges in the code, grids that are generated by the Grid class have one number associated with each edge.
        %> Those are by convention natural numbers for exterior edges and are zero for interior ones.
        %> You can display the edge IDs of a grid by <code>Grid.visualize('idE')</code>.
        idE % [#E x 1]      % edge ids
    end


    %   % check whether grid is periodic -- warn if global indexing is used
    %   methods
    %     function ret = get.coordV(obj)
    %       if isa(obj, 'FoldedGrid')
    %         warning('HyPHM:FoldedGrid:access', 'HyPHM: coordV must not be used if grid is folded.  Use coordV0T instead')
    %       end
    %       ret = obj.coordV;
    %     end
    %
    %     function ret = get.baryE(obj)
    %       if isa(obj, 'FoldedGrid')
    %         warning('HyPHM:FoldedGrid:access', 'HyPHM: baryE must not be used if grid is folded.  Use baryE0T instead')
    %       end
    %       ret = obj.baryE;
    %     end
    %   end


    % Note: Specified methods with the attribute Abstract must implemented by
    %       subclasses but possibly with different arguments.
    %  methods (Abstract)
    %   ...
    %  end

    methods (Static, Access = protected)
        [sigE0T, V2T, V2E, V0E, T0E, E0T] = evalTopology(coordV, V0T)
        [coordV0T, baryE0T] = evalLocGeometry(coordV, V0T, E0T, V0E);
        visualize_link(varargin)
        print_link(abstractGrid)
    end

end
